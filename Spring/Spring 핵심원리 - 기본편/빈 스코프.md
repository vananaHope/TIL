# 빈 스코프
* 빈이 존재할 수 있는 범위를 뜻함

**종류**
* 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
* 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
* 웹 관련 스코프
  * request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  * session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  * application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

**빈 스코프 지정**
* 컴포넌트 스캔 자동 등록
```
@Scope("prototype")
@Component
public class HelloBean {}
```
* 수동 등록
```
@Scope("prototype")
@Bean
PrototypeBean HelloBean() {
 return new HelloBean();
}
```

## 프로토타입 스코프
* 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다. 반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다

![image](https://github.com/vananaHope/TIL/assets/125250099/3b27a029-ad48-4dcb-910b-f63e075ba700)

* 프로토타입 스코프의 빈을 스프링 컨테이너에 요청
* 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다

![image](https://github.com/vananaHope/TIL/assets/125250099/701ff898-1d55-497a-889d-7d77e36a3f81)

* 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
* 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

**정리**

* **핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것**
* 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
* 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 @PreDestroy 같은 종료 메서드가 호출되지 않는다

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

![image](https://github.com/vananaHope/TIL/assets/125250099/9b2fd98b-1625-4c07-86b2-2a15ff3be5b8)

![image](https://github.com/vananaHope/TIL/assets/125250099/7f11178f-8927-4738-977b-57b9ec71c3d2)

![image](https://github.com/vananaHope/TIL/assets/125250099/e41ffd74-1a9b-425c-9f2f-92262b568ffd)

* clientBean은 싱글톤이므로 스프링 컨테이너 생성 시점에 함께 생성되고 의존관계 주입도 발생한다.
  * clientBean 은 의존관계 자동 주입을 사용한다. 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청한다.
  * 스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean 에 반환한다. 프로토타입 빈의 count 필드 값은 0이다.
* 이제 clientBean 은 프로토타입 빈을 내부 필드에 보관한다. (정확히는 참조값을 보관한다.)

![image](https://github.com/vananaHope/TIL/assets/125250099/609108c1-c0bb-4db6-85df-f8053fd81b37)

* 클라이언트 A는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은 clientBean이 반환된다.
* 클라이언트 A는 clientBean.logic() 을 호출한다.
* clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다. count값이 1이 된다

![image](https://github.com/vananaHope/TIL/assets/125250099/e25bcd92-4b9e-42f3-b38b-95b62813eba1)

* 클라이언트 B는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은 clientBean이 반환된다.
* clientBean이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈이다.
* 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다 새로 생성되는 것이 아니다.
* 클라이언트 B는 clientBean.logic() 을 호출한다.
* clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다. 원래 count 값이 1이었으므로 2가 된다

```
public class SingletonWithPrototypeTest1 {
   @Test
   void singletonClientUsePrototype() {
     AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class);
     ClientBean clientBean1 = ac.getBean(ClientBean.class);
     int count1 = clientBean1.logic();
     assertThat(count1).isEqualTo(1);

     ClientBean clientBean2 = ac.getBean(ClientBean.class);
     int count2 = clientBean2.logic();
     assertThat(count2).isEqualTo(2);
   }

   static class ClientBean {
     private final PrototypeBean prototypeBean;

     @Autowired
     public ClientBean(PrototypeBean prototypeBean) {
       this.prototypeBean = prototypeBean;
     }
     public int logic() {
       prototypeBean.addCount();
       int count = prototypeBean.getCount();
       return count;
     }
   }

   @Scope("prototype")
   static class PrototypeBean {
     private int count = 0;

     public void addCount() {
       count++;
     }
     public int getCount() {
       return count;
     }

     @PostConstruct
     public void init() {
       System.out.println("PrototypeBean.init " + this);
     }
     @PreDestroy
     public void destroy() {
       System.out.println("PrototypeBean.destroy");
     }
   }
}
```

* 스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 된다.
* 그런데 싱글톤 빈은 생성시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.
* 프로토타입 빈을 주입 시점에만 새로 생성하는게 아니라, 사용할 때 마다 새로 생성해서 사용하는 것을 원함.

**참고**
* 여러 빈에서 같은 프로토타입 빈을 주입 받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다. 
* 예를 들어서 clientA, clientB가 각각 의존관계 주입을 받으면 각각 다른 인스턴스의 프로토타입 빈을 주입 받는다.
  * clientA => prototypeBean@x01
  * clientB => prototypeBean@x02
